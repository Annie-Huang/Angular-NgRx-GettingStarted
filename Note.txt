Notes: D:\react\angular-ngrx-getting-started

https://github.com/DeborahK/Angular-NgRx-GettingStarted
https://github.com/Annie-Huang/Angular-NgRx-GettingStarted

https://github.com/ngrx/platform
https://blogs.msmvps.com/deborahk/angular-ngrx-getting-started-problem-solver/
https://github.com/angular/in-memory-web-api


D:\react\Angular-NgRx-GettingStarted>npm run start

How to change branch name in github:
Annie@Annie-PC MINGW32 /d/react/Angular-NgRx-GettingStarted (APM-Demo0-The-starter-files-for-this-course)
$ git branch -m 1-first-look-at-ngrx
Annie@Annie-PC MINGW32 /d/react/Angular-NgRx-GettingStarted (1-first-look-at-ngrx)
$ git push origin :APM-Demo0-The-starter-files-for-this-course 1-first-look-at-ngrx

Annie@Annie-PC MINGW32 /d/react/Angular-NgRx-GettingStarted (1-first-look-at-ngrx)
$ git push --delete origin APM-Demo0-The-starter-files-for-this-course


Introduction
############################
What Is State?
View State
User Information
Entity Data
User Selection and Input

Use NgRxWhen...
There is state everywhere!
- The store provides a place for UI state to retain it between router views
Getting data again and again!
- The store provides a client-side cache to use as needed
Notify everyone!
- The reducer updates the store and the store notifies all subscribers
Something isn't working!
- It has great tooling

Don't Use NgRxWhen...
Your team is new to Angular
- Ramp up with Angular and RxJSObservables first
The application is simple
- The extra code required for NgRxmay not be worth the effort
Your team has a good pattern
- No need to change if you already have a good state management pattern in place

The Redux Pattern
############################
Redux Principles
1. Single source of truth called the store
2. State is read only and only changed by dispatching actions
3. Changes are made using pure functions called reducers

What Should Not Go in the Store?
Unshared state
Angular form state
Non serializable state

Dispatch an Action to Change State
- Login action after a login form submission
- Toggle side menu action after a button click
- Retrieve data action when initializing a component
- Start global spinner action when saving data

Use Reducers to Change State
- Set a userDetails property on login
- Toggle a sideMenuVisible property to true on button click
- Set successfully retrieved data on component initialization
- Set a globalSpinnerVisible property to true while saving data

Advantages of the Redux Pattern
Centralized immutable state
Performance
Testability
Tooling
Component communication


First Look at NgRx
############################

https://github.com/angular/in-memory-web-api

D:\react\Angular-NgRx-GettingStarted>npm install
D:\react\Angular-NgRx-GettingStarted>npm run start

D:\react\Angular-NgRx-GettingStarted>npm install @ngrx/store@6.0.1


Feature Module State Composition
------------------------------------
App Module --
@NgModule({
  imports: [
    ...
    RouterModule.forRoot(appRoutes),
    StoreModule.forRoot(reducer)
  ],
  ...
})
Product Module --
@NgModule({
  imports: [
    ...
    RouterModule.forChild(productRoutes),
    StoreModule.forFeature('products', reducer)
  ],
  ...
})


Checklist: Dispatching an Action
-----------------------------------------
Often done in response to a user action or an operation
Inject the store in the constructor
Call the dispatch method of the store
Pass in the action to dispatch:
this.store.dispatch({
  type: 'TOGGLE_PRODUCT_CODE',
  payload: value
});
Passed to all reducers


Checklist: Subscribing to the Store
--------------------------------------------
Often done in the ngOnInitlifecycle hook
Inject the store in the constructor
Use the store's select operator, passing in the desired slice of state
Subscribe:
  this.store.pipe(select('products')).subscribe(
  products =>this.displayCode= products.showProductCode
);
Receives notifications when the state changes


Developer Tools and Debugging
####################################

D:\react\Angular-NgRx-GettingStarted>npm install @ngrx/store-devtools@6.0.1

Strongly Typing the State
####################################
Benefits of Selectors
Provide a strongly typed API
Decouple the store from the components
Encapsulate complex data transformations
Reusable
Memoized (cached)

Composing Selectors:
------------------------
products: {
  showProductCode: true,
  currentProduct: {...},
  products: [...]
},
exportconstgetCurrentProduct= createSelector(
  getProductFeatureState,
  getCurrentProductId,
  (state, currentProductId) =>
    state.products.find(p =>p.id === currentProductId)
);
Bottom line, when building selectors, define one for each bit of state that is accessed from the store 
and compose them as needed by your components and services.


Checklist: Strongly Typing State
-----------------------------------
Define an interface for each slice of state:
export interface ProductState {
  showProductCode: boolean;
  currentProduct: Product;
  products: Product[];
}
Compose them for the global application state
Use the interfaces to strongly type the state
import * as fromProduct from'./state/product.reducer';
...
constructor(privatestore: Store<fromProduct.State>){}

Checklist: Building Selectors
------------------------------
Build selectors to define reusable state queries
Conceptually similar to stored procedures
Feature selector:
const getProductFeatureState = createFeatureSelector<ProductState>('products');
State selector:
export const getShowProductCode = 
  createSelector(
    getProductFeatureState,
    state =>state.showProductCode
  );

Steps to build strongly type state:
===============================================
Strongly type the user state
Build selectors for maskUserName and currentUser
Modify the reducer to use the strongly typed state
Modify the login component to use the strongly typed state and selector


Strongly Typing Actions with Action Creators
#################################################
Benefits of Strongly Typed Actions
- Prevents hard to find errors
- Improves the tooling experience
- Documents the set of valid actions


Checklist: Strongly Typing Actions - 1
Define the action types
Use an enum to specify the set of named constants:
export enum ProductActionTypes {
  ToggleProductCode = '[Product] Toggle Product Code',
  SetCurrentProduct = '[Product] Set Current Product',
  ClearCurrentProduct = '[Product] Clear Current Product'
}
Specify clear action type strings


Checklist: Strongly Typing Actions - 2
Build an action creator
Define a class with type and payload properties:
export class ToggleProductCode implements Action {
  readonly type = ProductActionTypes.ToggleProductCode;
  constructor(public payload: boolean) {}
}
Use the action creator when dispatching the action:
this.store.dispatch(
  new productActions.ToggleProductCode(true)
);

Checklist: Strongly Typing Actions - 3
Union the action creators
Define a union type of all action creators:
export type ProductActions = ToggleProductCode
  | SetCurrentProduct
  | ClearCurrentProduct;
Use this union type in the reducer:
export function reducer(state = initialState, action: ProductActions)

Steps to change the action creator:
=============================================
Create an user.actions.ts file
Add an enumfor the action type (MaskUserName)
Build the associated action creator
Create a union type for the action creators
Modify the reducer to use the union type
Modify the login component to use the action creator


Working with Effects
#################################################
Benefits of Effects
Keep components pure
Isolate side effects
Easier to test

Effect is a type of angular service.

@Effect()
loadProducts$
The dollar suffix is an optional community convention to show that this variable is an observable, 
to be very clear about when you're dealing with the observable or the observables value. 

mergeMap(action =>
  this.productService.getProducts().pipe(
    map(products => (new LoadSuccess(products)))
  )
)
MergeMap maps over every emitted action calling Angular services who return observables, then merges these observables into a single stream. 

D:\react\Angular-NgRx-GettingStarted>npm install @ngrx/effects@6.0.1

When should you use the asyncpipe versus subscribing in a component class?
Component Subscription
this.productService.getProducts()
.subscribe(
  products=> this.products= products
);
Async Pipe
<div*ngIf="products$ | async">

Subscribe in the component when you need the observable's value in the component class, so to work with it or to change the value before using it in the template. 
If you do not need to do anything but subscribe and use the value in the template, then it's much easier to use an async pipe. 
If you don't need the value in the component, then technically it's just a syntactic difference and it's up to you which you'd prefer, as long as you unsubscribe. 











